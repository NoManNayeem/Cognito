# Cognito - Production-Ready Cognitive Memory Application

A sophisticated, dual-interface web application powered by a cognitive memory core. The system integrates **Cognee** for advanced knowledge graph management, **Agno** for high-performance agentic interaction, and **FastAPI** for orchestrating the entire system.

## Features

- **Knowledge Graph Management**: Advanced entity extraction and relationship mapping powered by Cognee
- **Agentic AI**: High-performance agentic interaction framework with stateful memory powered by Agno
- **Personalized Experience**: Context-aware conversations with conversation history and personalized user memories
- **Admin Dashboard**: Knowledge engineering lifecycle management (Ingestion → Cognification → Validation)
- **User Management**: Role-based access control with JWT scopes (admin/user)
- **Secure Authentication**: HTTP-only cookies with JWT tokens
- **Enhanced UI**: Modern, responsive interface with password show/hide, real-time validation, and improved error handling
- **Automatic Database Management**: Automatic admin user creation and database pruning on startup
- **Cookie-based Auth**: Secure cookie authentication with CORS support

## Technology Stack

- **Package Manager**: UV
- **Framework**: FastAPI with Jinja2 templates
- **Authentication**: JWT tokens with scopes (admin/user) stored in HTTP-only cookies
- **Cognitive Memory Layer**: Cognee (knowledge graph) + Agno (agentic interaction)
- **Database**: PostgreSQL (application database + Agno state database)
- **Graph Store**: Memgraph (or Kuzu)
- **Vector Store**: LanceDB (or Qdrant)
- **Frontend**: HTML + CSS + JavaScript + Bootstrap 5

## Prerequisites

- Python 3.12+
- UV package manager
- PostgreSQL (for application database and Agno state database)
- Memgraph or Kuzu (for knowledge graph storage)
- LanceDB or Qdrant (for vector embeddings)

## Installation

1. **Clone the repository**:
   ```bash
   git clone <repository-url>
   cd Cognito
   ```

2. **Create virtual environment with UV**:
   ```bash
   uv venv
   ```

3. **Activate virtual environment**:
   - Windows: `.venv\Scripts\activate`
   - Linux/Mac: `source .venv/bin/activate`

4. **Install dependencies**:
   ```bash
   uv pip install -e .
   ```

5. **Set up environment variables**:
   ```bash
   cp .env.example .env
   # Edit .env with your configuration
   ```

6. **Set up databases**:
   - Ensure PostgreSQL is running for both application database and Agno state database
   - Configure Memgraph/Kuzu for graph store
   - Configure LanceDB/Qdrant for vector store

7. **Run database migrations**:
   ```bash
   uv run alembic upgrade head
   ```

8. **Start the application**:
   ```bash
   uv run uvicorn app.main:app --reload
   ```

## Docker Installation (Recommended)

The easiest way to run Cognito is using Docker Compose, which sets up all required services automatically.

### Prerequisites

- Docker Engine 20.10+ (with BuildKit enabled for cache mounts)
- Docker Compose 2.0+
- `uv.lock` file (generated by running `uv lock`)

**Note**: This setup uses UV (a fast Python package manager) with optimized Docker builds including:
- Multi-stage builds for smaller images
- Build cache mounts for faster rebuilds
- Official UV binary from container registry
- System-wide installation (no virtual environment in Docker)

### Quick Start with Docker

1. **Set up environment variables**:
   ```bash
   cp .env.example .env
   ```
   Edit `.env` and set at minimum:
   - `LLM_API_KEY`: Your LLM provider API key (required)
   - `SECRET_KEY`: A secure secret key for JWT tokens
   - `ADMIN_PASSWORD`: Password for the admin user

2. **Build and start all services**:
   ```bash
   # Enable BuildKit for faster builds with cache mounts
   export DOCKER_BUILDKIT=1
   export COMPOSE_DOCKER_CLI_BUILD=1
   
   # Build and start
   docker-compose up -d --build
   ```
   
   **Note**: BuildKit is enabled by default in Docker Desktop. For Linux, you may need to enable it.

3. **View logs**:
   ```bash
   docker-compose logs -f app
   ```

4. **Access the application**:
   - Web UI: http://localhost:8000
   - API: http://localhost:8000/api

5. **Stop all services**:
   ```bash
   docker-compose down
   ```

### Docker Services

The Docker Compose setup includes:

- **app**: FastAPI application (port 8000)
- **postgres**: PostgreSQL for application database (port 5432)
- **agno-postgres**: PostgreSQL with pgvector for Agno state (port 5532)
- **memgraph**: Memgraph for knowledge graph storage (port 7687)

### Docker Database Connections

The application automatically connects to:
- **Application DB**: `postgresql://cognito:cognito_password@postgres:5432/cognito`
- **Agno DB**: `postgresql+psycopg://ai:ai@agno-postgres:5432/ai`
- **Memgraph**: `bolt://memgraph:7687` (handled by Cognee)

### Docker Volumes

Data persistence is handled via Docker volumes:
- `postgres_data`: Application database data
- `agno_postgres_data`: Agno state database data
- `memgraph_data`: Memgraph data
- `lancedb_data`: LanceDB vector store data
- `./app/static/uploads`: Uploaded files (mounted from host)

### Docker Development Mode

For development with hot-reload, create `docker-compose.override.yml`:

```yaml
version: '3.8'

services:
  app:
    volumes:
      - .:/app  # Mount source code
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
```

### Docker Common Commands

**View logs**:
```bash
# All services
docker-compose logs -f

# Specific service
docker-compose logs -f app
```

**Rebuild after code changes**:
```bash
# Rebuild with cache (faster)
docker-compose build app
docker-compose up -d app

# Or rebuild without cache (clean build)
docker-compose build --no-cache app
docker-compose up -d app
```

**UV Build Optimizations**:
- Uses official UV binary from `ghcr.io/astral-sh/uv:latest` (faster than pip install)
- Multi-stage build separates build dependencies from runtime
- Cache mounts (`--mount=type=cache`) speed up dependency installation
- `uv.lock` ensures reproducible builds with exact dependency versions
- System-wide installation (no virtual environment) reduces image size

**Run database migrations manually**:
```bash
docker-compose exec app alembic upgrade head
```

**Access database shell**:
```bash
# Application database
docker-compose exec postgres psql -U cognito -d cognito

# Agno database
docker-compose exec agno-postgres psql -U ai -d ai
```

**Reset everything** (⚠️ deletes all data):
```bash
docker-compose down -v
docker-compose up -d
```

**Check service health**:
```bash
docker-compose ps
```

### Docker Troubleshooting

**Application won't start**:
1. Check logs: `docker-compose logs app`
2. Verify databases are healthy: `docker-compose ps`
3. Ensure `.env` file exists with required variables

**Database connection errors**:
1. Wait for databases to be ready (healthchecks ensure this)
2. Check network connectivity: `docker-compose exec app ping postgres`
3. Verify environment variables are set correctly

**Migration errors**:
1. Check if databases are accessible
2. Run migrations manually: `docker-compose exec app alembic upgrade head`
3. Check Alembic version: `docker-compose exec app alembic current`

**Port already in use**:
1. Change port mapping in `docker-compose.yml`:
   ```yaml
   ports:
     - "8001:8000"  # Use different host port
   ```

**Out of memory**:
1. Increase Docker memory limit in Docker Desktop settings
2. Reduce number of services if running other containers

### Docker Production Considerations

For production deployment:

1. **Use strong secrets**: Set secure `SECRET_KEY` and `ADMIN_PASSWORD`
2. **Use HTTPS**: Set up reverse proxy (nginx/traefik) with SSL
3. **Backup volumes**: Regularly backup Docker volumes
4. **Resource limits**: Set memory/CPU limits in docker-compose.yml
5. **Environment isolation**: Use separate `.env` files per environment
6. **Monitoring**: Add logging and monitoring solutions
7. **Security**: Review and harden container security settings

Example production overrides:
```yaml
services:
  app:
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '1'
          memory: 1G
```

## Environment Variables

See `.env.example` for all required environment variables. Key variables include:

- `LLM_API_KEY`: API key for the LLM provider
- `LLM_PROVIDER`: LLM provider (e.g., openai, ollama)
- `LLM_MODEL`: Model name (e.g., gpt-4o-mini)
- `DB_URL`: PostgreSQL connection string for application database
- `AGNO_DB_URL`: PostgreSQL connection string for Agno state database
- `GRAPH_DATABASE_PROVIDER`: Graph database provider (memgraph or kuzu)
- `VECTOR_DB_PROVIDER`: Vector store provider (lancedb or qdrant)
- `SECRET_KEY`: Secret key for JWT token signing
- `ADMIN_USERNAME`: Username for first admin user
- `ADMIN_PASSWORD`: Password for first admin user

## Database Migrations

To create a new migration:
```bash
uv run alembic revision --autogenerate -m "Description of changes"
```

To apply migrations:
```bash
uv run alembic upgrade head
```

To rollback:
```bash
uv run alembic downgrade -1
```

## Usage

1. **Access the application**: Navigate to `http://localhost:8000`

2. **First Admin User**: The admin user is automatically created/updated from environment variables on startup. The system ensures:
   - Admin user always exists and matches `.env` configuration
   - Password updates automatically if changed in `.env`
   - Database is pruned (duplicates removed, data integrity ensured)
   - Admin user is always active with correct scopes

3. **Register New Users**: New users are created with `user` scope and inactive status by default

4. **Activate Users**: Admins can activate/deactivate users from the dashboard

5. **Upload Knowledge**: Admins can upload files (PDF, DOCX, TXT, MD) or add URLs to the knowledge base

6. **Process Knowledge**: Use the "Process" button to trigger cognification (knowledge graph creation)

7. **Chat Interface**: Active users can interact with the knowledge base through the chat interface

## Project Structure

```
Cognito/
├── app/
│   ├── __init__.py
│   ├── main.py                 # FastAPI app initialization
│   ├── config.py               # Configuration and environment variables
│   ├── database.py             # Database connection and session management
│   ├── models.py               # SQLAlchemy models (User, Role)
│   ├── schemas.py              # Pydantic schemas for request/response validation
│   ├── security/               # Authentication utilities
│   ├── routers/                # API routes
│   ├── services/               # Business logic (Cognee, Agno, Knowledge)
│   ├── templates/              # Jinja2 HTML templates
│   ├── static/                 # Static files (CSS, JS, uploads)
│   └── utils/                  # Utility functions (seed, file_handler)
├── alembic/                    # Database migrations
├── alembic.ini                 # Alembic configuration
├── pyproject.toml              # UV project configuration
├── .env.example                # Example environment file
└── README.md
```

## Development

### Running in Development Mode

```bash
uv run uvicorn app.main:app --reload
```

### Running Tests

(Add test commands when tests are implemented)

## Security Considerations

- All passwords are hashed with bcrypt
- JWT tokens stored in HTTP-only cookies (prevents XSS)
- CORS middleware configured with `allow_credentials=True` for cookie support
- Cookie security: `httponly=True`, `samesite="lax"`, `secure=False` in dev (HTTP), `secure=True` in production (HTTPS)
- CSRF protection for state-changing operations
- Input validation on all endpoints
- File upload validation (type, size limits)
- SQL injection prevention (SQLAlchemy parameterized queries)
- JWT scope-based access control on all protected routes
- Cognee authentication enabled (`REQUIRE_AUTH=true`)
- Automatic database pruning to maintain data integrity

## Database Utilities

The application includes utility scripts for database management:

```bash
# Run inside Docker container (recommended)
docker exec cognito-app python -m app.utils.db_utils <command>

# Or locally (if Docker database is accessible)
python -m app.utils.db_utils <command>
```

Available commands:
- `ensure-admin`: Ensure admin user exists and matches .env settings
- `prune`: Prune database (remove duplicates, fix data integrity)
- `full`: Run both prune and ensure-admin

## Recent Updates

- ✅ Enhanced UI with password show/hide toggle
- ✅ Improved error messages with icons and better UX
- ✅ Real-time form validation with visual feedback
- ✅ Fixed cookie authentication for dashboard access
- ✅ Added CORS middleware for proper cookie handling
- ✅ Automatic database pruning and admin user management
- ✅ Better error handling and logging

## License

(Add license information)

## Contributing

(Add contributing guidelines)
